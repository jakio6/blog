<h1 id="传输控制协议">传输控制协议</h1>
<p>-- 1981</p>
<h1 id="介绍">介绍</h1>
<p>传输控制协议(TCP) 是致力于数据包交换通信网络,以及这些网络相互连接组成的系统中高可靠性的主机到主机的协议</p>
<p>本文档介绍传输控制协议所要执行的功能,实现它的程序,以及它为需要它的程序和用户提供的接口</p>
<h2 id="动机">动机</h2>
<p>计算机通信系统在社会各界起着愈来愈重要的作用.此文档主要关注军用计算机通信的要求,尤其是在不可靠通信之上 通信的稳定性以及存在拥塞时的可用性,这些问题用眼存在于市政生活的方方面面</p>
<p>随着战略和战术用途的计算机通信网络的开发和部署,有必要为之提供相互通信的方式以及支持多数应用的进程间通信 协议.由于对这些标准的需求,xx机构已经宣布这里介绍啊的传输控制协议是DoD范围进程间通信协议标准的基础..</p>
<p>TCP是一个面向连接的,点对点可靠传输协议,xxx.TCP为位于不同网络但是相互连接的计算机上的进程对提供可靠进程间通信. 对于其下的通信协议的可靠性,几乎没有做出任何要求. TCP只期待能从底层协议获得简单的,可能不可靠的数据包服务. 原则上,TCP应该能够广泛应用于有线连接到分组交换或电路交换的网络..</p>
<p>TCP基于xxx首先提出的概念.TCP适用于IP协议之上的layer,IP协议为TCP提供发送和接收封装在"信封"中的长度补丁的网络 数据报的方式. 网络数据报提供了在不同网络寻址源和目标TCP的方式. IP协议还完成在多个网络和相互连接的网关之间 完成传输和发送需要分段和重组. IP 协议还包含有关TCP段的优先级,安全性,和区域信息,使得信息可以跨多个地域进行点对点 交换</p>
<p>此文档多数是在TCP实现在主机上与更高层的协议共存(??)的前提下写的. 一些计算机系统会通过通过TCP和IP以及专门的网络软件 所在的计算机前端连接到网络. TCP描述了给高层协议的一个接口,只要实现了前端的协议,其对主机到前端也是适用的.</p>
<h2 id="范围">范围</h2>
<p>TCP致力于提供在多元网络环境下提供可靠的进程到进程通信服务.致力于做多元网络中通用的主机到主机的协议</p>
<h2 id="关于">关于</h2>
<p>这个文档给出了任意TCP实现的行为的规范,包括其如何与高层协议交互,以及如何与其他TCP交互.这个章节中剩下的部分提供了 协议借口和操作的简要概括.第二章总结了TPC的设计哲学.第三章提供了对当TCP上事件发生(新的段到达,用户调用,错误,等等) 的时候需要的相应的详细描述以及TCP段的详细格式</p>
<h2 id="接口">接口</h2>
<p>TCP接口一端是用户或程序进程,另一端是像IP这样的底层协议</p>
<p>程序进程和TCP之间的接口会尽量详细地介绍.接口包含一套调用接口,类似于操作系统提供给程序操作文件的接口.比如,有用于 打开和关闭连接和在建立的连接之上发送和接受数据的接口. TCP最好还能和程序异步通信. 尽管在TCP的实现上提供了极大的 自由空间,对任何TCP/用户接口合法实现还是有着最基本的功能要求的</p>
<p>TCP和底层协议的接口基本上是没有指定的,除了需要有两个协议能异步交换信息的机制.通常,都是让底层协议来实现这个接口. TCP的设计是要能多数互联网络环境下工作.这个文档中所提到的所有底层协议都认为是IP</p>
<h2 id="操作">操作</h2>
<p>前面提到了,TCP的主要意图是为进程对提供可高,安全的逻辑电路或连接服务.要在不怎么可靠的互联网通信系统提供这个服务需要 设计到一下领域的知识:</p>
<ul>
<li>基础数据传输</li>
<li>可靠性</li>
<li>流控制</li>
<li>复用</li>
<li>连接</li>
<li>优先级和安全性</li>
</ul>
<p>TCP在这些领域中的基本操作在下面这个段落介绍:</p>
<p>基础数据传输:</p>
<p>TCP在它的用户之间的任一个方向进行连续的8bit字节流传输,通过将字节流封装到使用互联网系统系统传输的段.通常来说,TCP 会决定什么时候阻塞数据,什么时候发送数据</p>
<p>有时候用户需要确保他们提交给TCP的所有数据都成功发送.处于这个意图,定义了一个push函数.要确保提交给TCP的数据的数据 实际发送了,发送的用户提示其应该被push到接受用户. Push导致TCP快速发送和交付数据到接收方.实际的push点(节点?)可能对 接受方是不可见的并且push函数并未提供记录边界标记?</p>
<p>可靠性:</p>
<p>TCP必须恢复在互联网通信系统传输中受损,丢失,复用或者乱序的数据.这是通过给传输的每一个字节分配一个序列号来实现的, 并且要求收到接受方的肯定回复(ACK).如果在超时时限内没有收到回复,数据就会重发.在接收方,序列号用于纠正数据段的顺序和 消除重复.受损是通过给每一个传输的书记添加一个校验和来处理的,在接收方检查这个校验和,并且丢弃受损段</p>
<p>只要TCP处于正常工作状态并且网络系统没有分区(断开?),传输错误就不会影响数据的正确传输. TCP能够从互联网通信系统的 错误中回恢复</p>
<p>流控制:</p>
<p>TCP为接收方提供了管理接收方发送数据的量的方法.这是通返回xxx的"window"来实现的.window表示在收到进一步许可之前允许 传输的8bit字节的数量</p>
<p>复用:</p>
<p>要允许单个主机上的多个进程同时使用TCP通信工具,TCP在每个主机提供了一套地址或者端口. 来自互联网通信层的网络和主机 地址合并在一起,就构成了一个套接字.每一个连接都有一个套接字唯一标识.就是说,一个套接字可以在多个连接中同时使用???</p>
<p>端口到进程的绑定是由主机自己处理的.然而,将常用的进程附加到固定的为公众熟知的端口是很有用的.然后这些服务就可以通过 熟知地址访问.建立和了解其他进程的端口地址可能会设置到更多的动态机制</p>
<p>连接:</p>
<p>上面的可靠性和流控制机制需要TCP为每一个数据流初始化并位置特定的的状态信息. 这些信息,包括套接字,序列好,window大小 的组合,成为一个连接.每一个连接都是由其两端的套接字唯一标识的.</p>
<p>当两个进程想要进行通信的时候,他们的TCP必须先建立一个连接(初始化,在每一端初始化状态信息).当他们的通信完成的时候, 连接就会被终结或者关闭来释放资源</p>
<p>由于连接必须在不可靠的主机之间通过不可靠的通信协议建立,将使用带有基于时钟的序列号的握手机制来避免错误的初始化连接</p>
<p>优先级和安全性:</p>
<p>TCP的用户可能会强调他们的通信的安全性和优先级.在不需要这些机制的时候会使用规定的默认值</p>
<h1 id="哲学">哲学</h1>
<h2 id="互联网络系统的构成">互联网络系统的构成</h2>
<p>连接到网络的主机,网络又通过网关互联.在这里假设网络可能是区域性网络(意外网)或者大的网络(阿帕网,好像是因特网前身), 但是不论哪种都是基于包交换技术. 产生和消费信息的客户端是进程. 网络,网关和主机上的各种层次的协议构成了一个提供 进程端口间双向流控制和逻辑连接的互联通信网络.</p>
<p>术语packet在这里一般用于表示在主机和其网络中一次通信的数据.通常不关心在网络中交换的数据块的格式.</p>
<p>主机是附加到一个网络的计算机,从通信网络的角度看来,主机是packet的源头的目的地.进程被看做是主机电脑上有活跃元素(对应 普遍的是执行中的一个程序的进程定义). 甚至终端和文件以及其他IO设备都被看做是通过进程来相互通信的.因此,所有的通信都被看做 是进程间通信</p>
<p>由于一个进程可能会需要区分在其和另一个进程之间的一些通信流,我们假想每一个进程都有一个端口号,其与另一个进程的端口号进行通信</p>
<h2 id="操作的模型">操作的模型</h2>
<p>进程通过调用TCP并且讲数据缓冲区作为参数传递类来传输数据. TCP会将这些缓冲区中的数据封装成段,并且调用互联网模块来讲每个 数据段传输到目标TCP. 接受的TCP将来自段的数据置入接受用户的缓冲区并且通知接收用户. TCP会在这些段中添加控制信息来保证数据 的可靠传输</p>
<p>互联网通信的模型是有一个IP模块与每一个TCP对应,提供到局域网的借口. 这个互联网模块讲TCP段封装到互联网数据包中,并讲这些数据包 路由到目的互联网模块或者中间网关. 要在局域网中传输数据报,他们会被封装到一个局域网包中</p>
<p>packet交换机可能会执行进一步的封装,分段或者其他操作来完成间packet传输到目标互联网模块的目的</p>
<p>在网络之间的网关, 互联网数据包会从local包拆出来,并且检查目的地址来判断这些互联网数据包接下来要发送到哪里.然后互联网数据包 会再次封装到到下一个网络的本地包中并且路由到下一个网关,或者,目的地</p>
<p>允许网关将互联网数据包拆分成更小的互联网数据包(如果有必要的话).要这样做,网关会产生一组网络数据包,每一个都携带一个段. 各个 段在之后的网关可能还会被进一步拆分.网络数据包段的格式是有指定的,以便之后能够再重组成互联网数据报</p>
<p>目标互联网模块会从数据报中的将这些段拆分开来(在经过必要的重组之后)并且讲它交给目标TCP</p>
<p>这个简单的操作模型略过了多的细节. 一个重要的特征是服务的类型.其为网关(或者互联网模块(IP))提供信息来指导其选择在访问下一个网络 时使用的参数. 在服务类型信息中还包含数据包的优先级. 数据包还会携带安全信息来允许在多层安全环境中的主机和网关能够根据安全要求 隔离数据包</p>
<h2 id="主机环境">主机环境</h2>
<p>TCP被看做是操作系统中的一个模块. 访问TCP的用户就像是在访问文件系统一样.TCP可能会调用其他操作系统函数,比如,管理数据结构. 网络的实际接口一般认为是有一个设备驱动模块控制的.TCP并不直接调用网络设备驱动,而是调用互联网数据报协议模块,而调用谁被驱动 的工作由它完成</p>
<p>TCP的机制并不影响在前端处理器中实现TCP. 但是,在这样的一个实现中,主机到前端的协议就必须提供功能来支持这个文档中提到的TCP用户接口类型</p>
<h2 id="接口-1">接口</h2>
<p>TCP/用户接口提供给了TCP用户调用创建和关闭一个连接,发送和接受数据,获取连接信息的调用.这些调用就像操作系统中用户程序的其他调用, 比如打开,读写,关闭一个文件这种一样</p>
<p>TCP/internet接口提供了发送和接受寻址到互联网系统中任何一台主机数据报的调用. 这些调用有用于传递地址,服务类型,优先级,安全性和其他 控制信息的参数</p>
<h2 id="和其他协议的关系">和其他协议的关系</h2>
<p>下面的表格展示了TCP在协议中的层级:</p>
<pre><code>       +------+ +-----+ +-----+       +-----+                    
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level 
       +------+ +-----+ +-----+       +-----+                    
             |   |         |             |                       
            +-----+     +-----+       +-----+                    
            | TCP |     | RTP |  ...  |     |  Host Level        
            +-----+     +-----+       +-----+                    
               |           |             |                       
            +-------------------------------+                    
            |    Internet Protocol &amp; ICMP   |  Gateway Level     
            +-------------------------------+                    
                           |                                     
              +---------------------------+                      
              |   Local Network Protocol  |    Network Level     
              +---------------------------+                      

                         Protocol Relationships
</code></pre>
<p>TCP期望能够支持高效支持高级协议. ...</p>
<h2 id="可靠通信">可靠通信</h2>
<p>发送到TCP连接的数据流会按照顺序完整地送到目的地</p>
<p>传输的可靠性是通过使用序列号和ACK来实现的. 理论上来说,每一个octet都会分配一个序列号.一个段中第一个octet 的序列号会和那个段一起传输,并且叫做段序列号. 段还会携带一个ACK号码,反正就是用于确认的. 当TCP传输一个包含数据的段的时候,也会将同样的数据加入重传队列并且开始计时,当收到那个数据的ACK的时候,他就会从队列中删除. 如果在超时之前没有收到ACK,这个对应的段就会重传</p>
<p>一个ACK并不能保证数据发送到用户端了,但是接收端的TCP已经近了最大的努力了</p>
<p>要控制TCP之间的数据流,会使用一个流控制机制. 接收的TCP会想接收TCP汇报一个"window".其表明了接受的TCP目前想要接收的 从ACK开始的octet的数量</p>
<h2 id="连接建立和移除">连接建立和移除</h2>
<p>TCP提供了一个端口标识符来识别TCP可能会处理的数据流. 由于端口号是可以自由选择的,他们可能会重复. 要给每一个TCP提供唯一的地址,我们会用TCP的互联网地址加上端口号来创建一个在整个互联的网络中唯一的套接字.</p>
<p>连接由两端的套接字唯一制定. 本地套接字可能会参与到与许多外部套接字的连接中.连接的每个方向都可以传送数据, 也就是完全复用,全双工(为什么起个这么名字)</p>
<p>TCP端口和进程的绑定是随意的,但是,在任何实现中一些基础的概念都是有必要的.必须要有只与某种用途进程关联的知名套接字. 我们认为进程可以拥有端口,并且那些进程只能在他们拥有的端口上建立连接(就是实现所有权是本地的问题,但是我们谁像了请求端口 用户命令,或者将一组端口唯一地分配给特定进程的方法,比如,通过讲端口的高位数据与一个给定的进程管理)</p>
<p>OPEN调用中的本地端口外部套接字参数指定了一个连接. TCP会返回一个(简短的)本地连接名来用于在之后的调用中引用那个连接. 我们假设有一个叫做传输控制块(TCB)的数据结构来保存这个信息.一个可能的实现策略是使用指向对应连接的TCB的指针作为本地 连接名. OPEN调用还指定连接是主动连接还是等待连接</p>
<p>被动的OPEN请求意味着进程想要接受一个到来的请求而不是试图建立一个连接. 通常发起被动OPEN请求的进程会接受来自 任何调用者的请求.这种情况下会使用一个全0的外部套接字来表示一个未指定的套接字??.未指定的外部套接字只允许出现在 被动形式OPEN中</p>
<p>想要给其他未知进程提供服务的服务进程通常会想要使用一个未指定的外部套接字来发情一个被动的OPEN请求.然后可以与 在这个套接字上请求连接的进程建立连接. 如果都知道这个本地套接字是和这个服务关联就更好了</p>
<p>知名套接字是将套接字地址与标准服务优先关联的便利机制. 比如,telnet服务器进程总是分配一个特定的套接字,其他还有 为远程文件传输,远程作业入口,文本生成器,Echoer以及Sink进程(最后三个是测试用的(???)). 可能还会专门给返回新创建 的服务会使用的套接字的查找服务保留套接字. 知名套接字的概念是TCP规范的一部分, 但是如何给服务分配套接字就不在 规范的范围了</p>
<p>进程可以发起被动的OPEN并且等待匹配的来自其他进程的主动OPEN,在连接建立的时候TCP会通知. 同时发起向对方的主动 OPEN的两个进程能够成功建立连接.这种灵活性对于分布式计算至关重要,在分布式计算中,组件彼此异步运行</p>
<p>匹配本地的被动OPEN和外部的主动OPEN两种主要的情形.第一种,本地的被动OPEN完整地指定了外部套接字. 这种情况下,必须 完全匹配. 第二种情况中,本地被动OPEN不会指定外部套接字. 这种情况下,只要本地套接字匹配了就会接受. 其他可能还包括 部分限制的匹配</p>
<p>如果在相同的本地套接字上有多个等待的被动OPEN(记录在TCB),外部OPEN会优先匹配套指定了这个外部套接字的TCB</p>
<p>建立连接的过程会用到同步控制(SYN)标识并且涉及到三则信息的交换.这个交换专门的术语是"三次握手"...</p>
<p>连接在收到一个包含SYN的到来段.....的时候发起建立. 本地和外部套接字的匹配决定了什么时候完成发起连接. 在序列号在两个 方向上都同步了之后连接完成建立</p>
<p>连接的移除同样涉及到段的交换,这个情况下会携带FIN控制标识</p>
<h2 id="数据通信">数据通信</h2>
<p>在连接之前流动的数据被看做是字节(octet)流. 发送用户在每一个SEND调用中通过PUSH标识表明那个调用是否应该马上推送到 接收用户</p>
<p>发送端TCP可以收集来自发送用户的数据并自行决定在什么时候发送数据, 除了在收到push信号的时候必须发送所有没有发送的数据. 当接收TCP看到PUSH标识的时候,他必须马上将数据提交给接收进程</p>
<p>在push函数和段界限之间没有必然的关系.每个段中的数据都可能是一个SEND调用全部或者部分的数据,或者多个SEND调用的数据(??)</p>
<p>push函数和PUSH标识的意图是讲发送用于推送到接收用户. 并不提供记录服务(pop?)</p>
<p>在push函数和crossTCP/用户接口的缓冲区数据的使用存在耦合(??).每当PUSH标识和置入接收用户的数据关联的时候,缓冲区会立即 返回接收用户的缓冲区,及时缓冲区还没有填充. 如果到来的数据在出现PUSH之前就填满了用户的缓冲区,数据会以buffer大小的单元 提交给用户</p>
<p>TCP还提供了一种与接收者通信的方式,其是不在接受者正在读的数据流之中的紧急数据,之后会讨论. TCP不会试图定义用户在收到 紧急数据通知的时候要怎么做,但是通常建议接收进程快速处理紧急数据</p>
<h2 id="优先级和安全性">优先级和安全性</h2>
<p>TCP会使用互联网协议的服务域以及安全选项来提供TCP用户连接的优先级和安全性. 不是所有TCP模块都是 在多层的安全环境下工作的,有些可能仅限于未分类的使用,其他的可能只在安全级和隔离的情况下使用.(??) 所以,有些TCP实现并向用户提供了多层安全级情况下的一个子集</p>
<p>在多级安全环境下操作的TCP模块必须恰当地标记输出段的安全级,隔离和优先级.这样的TCP模块还必须提供给 他们的用户或者高层协议用于指定想要的连接的这些属性的接口</p>
<h2 id="完备性原则">完备性原则</h2>
<p>TCP实现会遵循一般的完备性原则: 对于要做的事保守,在接收的时候保持自由 (??)</p>
<h1 id="3-functional-specification">3 functional specification</h1>
<h2 id="header格式">header格式</h2>
<p>TCP段将在互联网(也就是IP啦)数据报中发送.IP头携带了一些信息域,包括源和目标主机地址. TCP头就在IP头之后, 提供TCP协议的信息.这个划分允许TCP之外的主机层协议存在</p>
<p>TCP header 格式:</p>
<pre><code>                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            一个刻度表示一个bit
</code></pre>
<p><strong>源端口: 16位</strong></p>
<p>源端口号</p>
<p><strong>目的端口: 16位</strong></p>
<p>目的端口号</p>
<p><strong>序列号: 32位</strong></p>
<p>这个段中第一个数据字节的序列号(除了有SYN的时候).如果出现了SYN,则这个序列号是初始序列号(ISN).并且第一个自己是ISN+1</p>
<p><strong>ACK号: 32位</strong></p>
<p>如果ACK控制位设置了,则这个位包含这个段的发送者想要收到的下一个序列号.一个连接建立这个总是会不断发送(??)</p>
<p><strong>数据偏移: 4位</strong></p>
<p>TCP header中32bit字的数量. 表明数据从哪里开始. TCP header(甚至包含选项的)是一个32bit的整数</p>
<p><strong>保留: 6位</strong></p>
<p>保留以后使用,必须是0</p>
<p><strong>控制位: 6位(从左到右)</strong></p>
<p>URG : Urgent指针域有效 ACK : Ack域有效 PSH : push函数 RST : 重置连接 SYN : 同步序列号 FIN : 不再接收来自发送者的数据</p>
<p><strong>window : 16位</strong></p>
<p>这个段的接受者能够接受的从ACK域中表示的字节开始的字节数量</p>
<p><strong>校验和: 16位</strong></p>
<p>header和text中所有16bit字的反码和的16位反码.如果一个段的header和text字节数为奇数,最后一个字节会0填充成 16bit字来用于校验和.填充的不参与传输.在计算校验和的时候,检验和域的位置会被填充成0 校验和还涵盖了一个概念性前缀TCP header的96bit伪header.这个伪header包括原地址,目标地址,协议,tcp长度.这将帮助TCP避免 转发错误的段.这个信息处于IP协议中,是通过TCP调用的参数(实在看不懂)给出或者是TCP调用IP的结果</p>
<pre><code>
                     +--------+--------+--------+--------+
                     |           Source Address          |
                     +--------+--------+--------+--------+
                     |         Destination Address       |
                     +--------+--------+--------+--------+
                     |  zero  |  PTCL  |    TCP Length   |
                     +--------+--------+--------+--------+
</code></pre>
<p>TCP长度是是TCP header的字节长度加上数据的字节长度(不是有效传输数据,而是经过计算的),并且它不会包含伪header中的12个字节</p>
<ul>
<li>Urgent Pointer: 16位</li>
</ul>
<p>从这个段的序列号开始的urgent pointer的正向偏移,urgent pointer指向urgent数据开始的字节.只在有URG控制位的段中才有效</p>
<p><strong>选项: 不定长度</strong></p>
<p>选项可能会在TCP header的末尾出现,并且长度是8bit的整数倍(整字节,或者说8bit字节,octet).所有的选项都包含在校验和中.选项 可以在任何字节界限开始. 一个(可能会有多个)选项的格式有两种情形:</p>
<ul>
<li>一字节的选项类型</li>
<li>一字节的选项类型,一个字节的选项长度,以及实际的选项数据字节</li>
</ul>
<p>选项长度统计选项类型和选项长度两个字节以及选项数据字节的(???)</p>
<p>选项的列表可能短于数据偏移域暗示(计算)的长度.header在选项尾之后的数据必须是填充</p>
<p>TCP必须实现所有的选项</p>
<p>目前定义的所有选项:</p>
<pre><code>
      Kind     Length    Meaning
      ----     ------    -------
       0         -       End of option list.
       1         -       No-Operation.
       2         4       Maximum Segment Size.
</code></pre>
<p>特定选项的定义:</p>
<p>选项列表结束:</p>
<pre><code>        +--------+
        |00000000|
        +--------+
         Kind=0

</code></pre>
<p>这个选项码表示选项列表结束.这个可能不会和根据数据偏移计算出的TCP header的末尾重合.用于全部选项结束处, 不是每一个选项末尾,并且只在选项末尾不和TCP header末尾重合的时候才使用</p>
<p>无操作:</p>
<pre><code>        +--------+
        |00000001|
        +--------+
         Kind=1
</code></pre>
<p>这个选项码可以用于选项之间,比如,用于对其下一个选项到字边界. 不保证发送者会使用这个选项. 因此接受者必须 做好处理没有对齐的选项的准备</p>
<p>最大段大小:</p>
<pre><code>        +--------+--------+---------+--------+
        |00000010|00000100|   max seg size   |
        +--------+--------+---------+--------+
         Kind=2   Length=4
</code></pre>
<p>最大段大小选项数据: 16位</p>
<p>如果给出了这个选项,则其表明了在发送这个段的TCP最大能接受的段大小.这个域必须只在初始连接请求中发送(也就是 设置了SYN控制位的段). 如果这个选项没有只用,允许任意大小的段</p>
<p><strong>填充: 不定长度</strong></p>
<p>TCP header的填充用于确保TCP header的结束和数据的开始是在32bit的字节界限. 0填充</p>
<h2 id="术语">术语</h2>
<p>在进一步讨论TCP的操作之前需要先介绍一些专门的术语. TCP的连接的维护需要记忆一些变量.我们认为这些变量 是存在一个叫做传输控制块(TCB)的连接记录中. 保存在TCB中的变量有远端套接字值, 连接的安全性和优先级, 用户的发送和接受缓冲区的指针,重发队列和当前段的指针.此外还有一些与发送和接收序列号有关的变量也存在TCP中</p>
<p>序列发送变量:</p>
<ul>
<li>SND.UNA - 不到ACK发送</li>
<li>SND.NXT - 发送下一个</li>
<li>SND.WND - 发送window</li>
<li>SND.UP - 发送ungent pointer</li>
<li>SND.WL1 - 用于最后一次window更新的段序列号</li>
<li>SND.WL2 - 用户最后一次window更新的ACK编号</li>
<li>ISS - 初始发送序列号</li>
</ul>
<p>序列接收变量</p>
<ul>
<li>RCV.NXT - 接收下一个</li>
<li>RCV.WND - 接收window</li>
<li>RCV.UP - 接收 Urgent pointer</li>
<li>IRS - 初始接收序列号</li>
</ul>
<p>下面的表可能能帮助将这些变量与序列空间关联起来 (??)</p>
<p>发送序列空间(send sequence space):</p>
<pre><code>
                   1         2          3          4      
              ----------|----------|----------|---------- 
                     SND.UNA    SND.NXT    SND.UNA        
                                          +SND.WND        

        1 - 已经ACK的就的序列号
        2 - 未ACK的数据的序列号
        3 - 允许用于新的数据传输的序列号
        4 - 目前暂不允许的之后的序列号

                          Send Sequence Space
</code></pre>
<p>send window是上面标号3的空间</p>
<p>接收序列号空间:</p>
<pre><code>
                       1          2          3      
                   ----------|----------|---------- 
                          RCV.NXT    RCV.NXT        
                                    +RCV.WND        

        1 - 已经ACK的旧的序列号
        2 - 允许接收的新的序列号
        3 - 目前还不允许的之后的序列号

                         Receive Sequence Space
</code></pre>
<p>recive window是上面标号为2的空间</p>
<p>还有一些在讨论中经常使用的变量,他们的值都是从当前段获取的</p>
<p>当前段变量:</p>
<ul>
<li>SEG.SEQ - 段序列号</li>
<li>SEG.ACK - 段ACK号</li>
<li>SEG.LEN - 段长度</li>
<li>SEG.WND - 段window</li>
<li>SEG.UP - 段urgent pointer</li>
<li>SEG.PRC - 段优先级</li>
</ul>
<p>一个完整的连接会经过一系列的状态. 这些状态是: LISTEN, SYN-SENT, SYN-RECEVIED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2,CLOSE-WAIT, CLOSING, LAST-ACK,TIME-WAIT, 以及虚构的CLOSED状态,CLOSED表示没有TCB了,也就是没有连接的,这些状态的简要含义是:</p>
<ul>
<li>LISTEN - 表示等待来自任意远端TCP和端口的连接</li>
<li>SYN-SENT - 表示在发送连接请求之后等待匹配的连接请求</li>
<li>SYN-RECEVIED - 表示在已经发送和接收一个连接请求之后等待一个确认连接请求</li>
<li>ESTABLISHED - 表示一个打开的连接, 收到的数据可以发送给用户. 连接数据传输阶段的一般状态</li>
<li>FIN-WAIT-1 - 表示等待来自远端TCP的连接结束请求, 或者对先前已经发送的连接终结请求的ACK.</li>
<li>FIN-WAIT-2 - 表示等待来自远端TCP的连接终结请求</li>
<li>CLOSE-WAIT - 表示等待来自本地用户的连接终结请求</li>
<li>CLOSING - 表示等待来自远端TCP的连接终结请求的ACK</li>
<li>LAST-ACK - 表示等待对先前发送给远端的连接终结请求的ACK(包含对其(远端TCP?)连接终结请求的确认)</li>
<li>TIME-WAIT - 表示等待足够的时间来确保远端TCP收到它的连接终结请求</li>
<li>CLOSED - 表示没有连接状态</li>
</ul>
<p>TCP从一个状态转到另一个状态以相应事件.这些事件是用户调用 OPEN,SEND,RECEIVE,CLOSE,ABORT和STATUS,段的到来,特别是包含SYN,ACK,RST, 和FIN标志的段的讨来,以及超时</p>
<p>下面的状态表只展示了状态改变以及起因时间和结果,但是不涉及错误状况和与状态改变无关的行为.在之后或提供 更详细的TCP对事件的响应:</p>
<blockquote>
<p>这个表只是一个总结,不要当做总的规范!</p>
</blockquote>
<pre><code>                              +---------+ ---------\      active OPEN  
                              |  CLOSED |            \    -----------  
                              +---------+&lt;---------\   \   create TCB  
                                |     ^              \   \  snd SYN    
                   passive OPEN |     |   CLOSE        \   \           
                   ------------ |     | ----------       \   \         
                    create TCB  |     | delete TCB         \   \       
                                V     |                      \   \     
                              +---------+            CLOSE    |    \   
                              |  LISTEN |          ---------- |     |  
                              +---------+          delete TCB |     |  
                   rcv SYN      |     |     SEND              |     |  
                  -----------   |     |    -------            |     V  
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |&lt;-----------------           ------------------&gt;|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |&lt;-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------                  
   |                  x         |     |     snd ACK                    
   |                            V     V                                
   |  CLOSE                   +---------+                              
   | -------                  |  ESTAB  |                              
   | snd FIN                  +---------+                              
   |                   CLOSE    |     |    rcv FIN                     
   V                  -------   |     |    -------                     
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |  
   | --------------   snd ACK   |                           ------- |  
   V        x                   V                           snd FIN V  
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |  
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  
   |  -------              x       V    ------------        x       V  
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |
                              +---------+                   +---------+

                      TCP Connection State Diagram
</code></pre>
<h2 id="序列号">序列号</h2>
<p>这个设计中的一个最基础的概念就是每一个通过TCP发送的字节都有一个序列号. 由于每一个字节都是有序号的,他们每一个都可以ACK. 用到的ACK机制是累累计的,因此序列号X的ACK可以表明X之前的所有字节都已经接收了.这个机制允许在存在重传的情况下进行直接 进行重复检测. 一个段内字节的编号规则是header之后的第一个字节是最小编号,之后的递增</p>
<p>有必要知道实际的序列编号空间是有限的,虽然很大.这个空间从0到2^32-1. 由于这个空间是有限的,所有处理序列号的运算必须执行 模2^32. 这个无符号运算保留了序列号之间的关系,因此它们可以再次从2^32-1到0循环(反了吗??). 还有一些用于计算模运算的 subleties,因此在比较这些值的时候必须要格外小心(??)</p>
<p>TCP必须进行的典型序列号比较操作包括:</p>
<ul>
<li>判断一个ACK指代某个已经发送但是还没有收到ACK的序列号</li>
<li>判断一个段占用的所有序列号都已经ACK了(从重传队列中对应的段)</li>
<li>判断进入段包含期望的序列号(段处于receive window中)</li>
</ul>
<p>TCP在发送数据之后会收到ACK. 下面的这些比较在处理ACK的时候是需要用到的.</p>
<ul>
<li>SNS.UNA = 就的ACK序列号</li>
<li>SND.NXT = 下一个发送的序列号</li>
<li>SEG.ACK = 来自接收方的ACK(接收TCP下一个想要的序列号)</li>
<li>SEG.SEQ = 一个段的第一个序列号</li>
<li>SEG.LEN = 段中的数据占据的字节数(计算SYN和FIN(???))</li>
<li>SEG.SEQ + SEG.LEN-1 = 一个段的最后一个序列号</li>
</ul>
<p>一个新的ACK(叫做可接受ACK),处于以下不等式表示的范围:</p>
<pre><code>  SND.UNA &lt; SEG.ACK =&lt; SND.NXT
</code></pre>
<p>重传队列中的一个段的序列号和长度小于等于进入段的ACK值的话,它就完全传输了</p>
<p>在接收到数据的时候需要进行以下比较:</p>
<ul>
<li>RCV.NXT = 希望收到的下一个序列号,并且是处理接收窗口的左或下侧(??)</li>
<li>RCV.NXT + RCV.WND-1 = 在一个进入段期望出现的序列号的最后一个,并且是接收串口的右或上侧</li>
<li>SEG.SEQ = 进入段占据的第一个序列号</li>
<li>SEQ.SEQ + SEG.LEN - 1 = 一个进入段占据的最后一个序列号</li>
</ul>
<p>如果输入段占据的范围符合以下不等式,则认为是合法的:</p>
<pre><code>    RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND
</code></pre>
<p>或者</p>
<pre><code>    RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND
</code></pre>
<p>这个测试的第一个部分检查输入段的开始是否落在窗口范围内,第二部分是检查输入端的结尾是否落在输入窗口内,如果 段通过了这两个测试,那么它包含的数据就处于窗口内</p>
<p>实际上,比这个还要负载.由于存在0窗口和0长度段,有四种情况:</p>
<pre><code>
    Segment Receive  Test
    Length  Window
    ------- -------  -------------------------------------------

       0       0     SEG.SEQ = RCV.NXT

       0      &gt;0     RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND

      &gt;0       0     not acceptable

      &gt;0      &gt;0     RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND
                  or RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND
</code></pre>
<p>注意在接收窗口为0的时候不接受出ACK段之外的段. 因此,TCP在传输数据和接收ACK的时候可以维持一个0大小的窗口(发送). 但是,及时接收窗口是0,TCP也必须处理所有输入段中的RST和URG域</p>
<p>我们还会利用编码机制来保护特定的控制信息.这是通过在序列空间中隐式地包含一些控制表示,使得他们在重传和ACK的时候不会有歧义 ().控制信息不没有携带在段数据中.所以我们必须采取给隐式分配序列号给控制的方式. SYN和FIN是唯一需要这个保护的控制选项, 并且这些控制标识只用在连接打开和关闭的时候.在用作序列号用于的时候,认为SYN在它出现的段的实际数据之前出现,FIN在 最后一个实际数据之后出现(???). 段长度(SEG.LEN)包含数据和占据控制的序列空间.当一个SYN出现的时候,SEG.SEQ是SYN的序列号.</p>
<p>初始序列号选择</p>
<p>协议没有对重复使用的特定连接进行限制. 连接是由套接字对定义的. 一个连接的新的实例江北看做是连接的incarnation. 由此而来的问题是,TCP如何标识来自先前的实例中的重复段?如果连接的打开和关闭之间间隔很短,或者连接由于丢失内存而中断 之后又重新建立的时候就很明显了.</p>
<p>要避免混淆我们避免使用来自先前连接实例的段.我们想要确保这一点,即使在一个TCP崩溃并且丢失了他已经使用过的所有序列号 的时候也是如此.当新的连接建立的时候,会使用一个初始序列号(ISN)生成器,来生成一个32位ISN. 这个生成器是捆绑到到一个 (可能是假想的)一个低位大约每4us(microsecond...)增加一次的32位时钟.因此,ISN大概每4.55小时循环一次.因为我们认为段在网络中存留的时间 不会超过最大段生存时间(MSL)并且那个MSL会小于4.55个小时,我们有理由认为ISN是唯一的</p>
<p>对于要建立或者初始化的连接,两个TCP必须同步另一个的初始序列号.这是通过交换携带SYN控制位和ISN的连接建立段来完成的. 简单点,吧携带SYN位的段叫做SYNs.因此,这个解决方案需要选择一个初始序列号和简单的交换ISN的握手</p>
<ol>
<li>A --&gt; B SYN 我的序列号是X</li>
<li>A &lt;-- B ACK 你的序列号是X</li>
<li>A &lt;-- B SYN 我的序列号是Y</li>
<li>A --&gt; B ACK 你的序列号的Y</li>
</ol>
<p>因为步骤2和3可以捆绑到单则消息中,这个过程叫three way handshake</p>
<p>三次握手是必须的,因为序列号并没有绑定到网络通用时钟,并且各个TCP可能有不用的选择ISN的机制. 不能通过第一个SYN的接收 判断这个段是不是一个旧的延时的段,除非它记录了在这个连接中用过的最后一个序列号(不怎么可能). 因此它必须要让发送者 验证这个SYN. 三次握手和时钟驱动的方案的优势会在之后讨论</p>
<p>知道什么时候保持静默</p>
<p>要确保TCP没有创建一个携带了可能被仍然留在网络中的段使用的序列号,TCP在启动或者恢复后分配序列号的时候必须保持MSL 时间长度的静默. 对于本规范MSL采用2min. 这个是试验性的选择,如果实际表明需要改变的话,可能会改变. 注意,如果TCP在 某些情境下重新初始化了,并且重新获取了正在使用的序列号内存,则不需要等待. 只需要确保使用大于最近使用的序列号就行.</p>
<p>TCP静默时间概念</p>
<p>本规范假设主机崩溃并且没有恢复连接上最后使用的最后一个序列号的信息时在主机所在的网络应该延迟至少MSL时间发送TCP段. 在下面的段落中,会给出对这个指定的届时. TCP实现者可能会违反静默时间限制,但是这只会导致某些旧的数据被用做新的,或者 新的数据因为旧的占用而被拒绝.</p>
<p>TCP会在新的段构造出,并且进入了源主机的网络输出队列的时候消费序列号空间. TCP协议中的复用检测和归序算法依赖与段数据 到序列的空间的唯一绑定,在绑定到这些序列号的端数据已经传输完成并且收到了接收者的ACK并且所有复用的的复制已经存互联网 "耗尽"的之前不会再次循环2^32个值. 如果没有这样的一个假设,两个不同的TCP段可能会被分配想用的或者重复的序列号,导致 接收者对数据的新旧的困惑. 要知道,每个段中都绑定了与段中的字节数一样多的连续序列号.</p>
<p>在一般情况下, TCP会跟进下一个要生成的序列号,以及最旧的尚未得到的ACK,以此来避免在一个序列号还没有得到ACK之前重复使用. 单单是这样还不能保证旧的复用数据已经从网络中耗尽,因此序列的空间已经做的足够大来减少一个迷路的重复数据在到达的时候 导致麻烦的可能性. 在2m bit/s的时候,需要花费4.5个小时才能耗尽序列空间中的2^32个字节(2^32/(4.5x60x60x2^21/8)). 因为网络中的MSL最多不会超过几十秒,这个保护已经足够充分了,即使是在数10mb/s的时候. 在100mb/s的时候,循环的时间是5.4min, 可能有一点短,但是仍然在可接收的范围(现在网速多少了....上G了吧)</p>
<p>但是TCP中的基础复用检测和归序算法也是有缺陷的,像是源TCP没有足够的给最近连接中使用的序列号的内存.比如,如果TCP的所有 连接都从序列号0开始,那么崩溃和重建的时候,TCP可能会重新创建早先使用的连接(可能是在半开连接解决之后(??))并且使用与 仍在网络中的同一个连接早先发送的包相同或者重叠的序列号. 在对特定连接早先使用的序列号不知情的情况下,TCP规范推荐 延迟MSL秒来等待先前连接的包耗尽.</p>
<p>及时主机可以记录时间并且使用它来选择初始序列号也不能避免这个问题</p>
<p>设想,一个连接从序列号S开始. 假设这个连接并没有使用太多,然后ISN(t)获得了一个和这些序列号一样的值,S1,它也是这个TCP在 某个特定的连接中最后发送的段的序列号. 那么现在,在这个实力中,主机崩溃了,回复,并且建立了一个新的连接实例. 其选择的 初始序列号S1 = ISN(t) -- 在旧实例中最后使用的序列号!如果恢复得足够快的话,在网络中阻塞的重复数据包可能会到来并且被 当做新的连接发送的数据包.</p>
<p>问题在于回复的主机不知道它崩溃了多久了,也不知道旧的实例是否还有重复的数据包存留.</p>
<p>一个办法是直接在回复后延迟MSL长的时间,也就是这个规范中的静默时间. 不想等待而宁愿冒险的主机可以选择不做这个等待. 实现着应该为TCP使用者提供这种选择的权利. 明显,即使一个用户选择等待,主机上线超过MSL时间之后也没有必要了(??)</p>
<p>总结: 每一个生成的段都占据序列空间中的一个或多个序列号, 被占用的熟知在MSL时间之内都是处于busy或者in use的状态, 在崩溃的时候有一段空白时间是被上次发送的段占据的,如果新的连接启动地过快并且使用了上一个连接实例留在空白时间中 重复的序列号,就可能会导致接收方序列号的重叠,导致混淆</p>
<h2 id="建立连接">建立连接</h2>
<p>建立连接就是三次握手的过程. 这个过程通常是由一个TCP发起,由另一个TCP相应.这个步骤在两个TCP同时发起的时候也可以工作. 当同时请求的情况出现的时候,每一个TCP在发送一个SYN之后都会收到一个不带ACK的段.当然,旧的重复的SYN段存在的时候也可能会 导致出现这样的情况, 对接收者而言, 是正在进行同步连接初始化. 恰当使用reset段可以区分这些情况.</p>
<p>接下来有几个连接初始化的例子.尽管这些示例没有显示使用数据承载段的而连接同步,但是这是完全可以的,只要TCP在确认数据是 有效的之前没有想用户发送它就行的.(就是说,数据必须在接收方这里缓存,直到连接进入ESTABLISHED状态).三次握手减少了错误 连接的可能性.这是在内存和提供这个检查的消息之间权衡的实现</p>
<!-- Wed, 27 Mar 2019 14:42:23 +0800 -->

<p>最简单的三次握手在下面的表中展示了.这个表格应该按照以下的顺序届时. 每一行都的编号都是方便引用的.--&gt; 表示从TCP A到B的段的发送..或者A发送的段达到B.. &lt;-- 相反, (...)表示段仍然处于网络中(延时了). XXX表示丢失或者被拒绝的段. 注释出现在括号中.TCP状态表示段(内容在每一行中心展示)离开或达到之后的状态.段内容以序列号,控制表示以及ACK域的缩写表示. 其他的为了简洁暂不考虑</p>
<pre><code>
      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED

  3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED

  4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED

  5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED

          Basic 3-Way Handshake for Connection Synchronization
</code></pre>
<!-- Wed, 27 Mar 2019 14:59:56 +0800 -->

