<h1 id="页转换">页转换</h1>
<p>地址转换的第二个步骤中,80386会将线性地址转换为物理地址,这个步骤中 这个地址转换的步骤实现了页级虚拟内存系统和页级保护的基础特性.</p>
<h2 id="页帧">页帧</h2>
<p>页帧是物理地址中一块4k的连续的内存区域. 页从字节边界开始,大小固定</p>
<h2 id="线性地址">线性地址</h2>
<p>线性地址通过指定一个页表,表中的一个页,以及那个页中的偏移, 来间接引用物理地址,</p>
<p>处理器通过访问两级页表来将线性地址的DIR,PAGE,OFFSET区域转换为物理 地址.寻址机制使用DIR作为页目录中的索引,使用PAGE作为页目录中索引, 使用OFFSET寻址页表决定的一个页中的字节</p>
<h2 id="页表">页表</h2>
<p>页表是一个简单的三十二字节的页指示符. 页表自身也是一个页,因此, 其可以包含4k字节或者1k32bit的条目</p>
<p>两级表用于寻址一页内存.最顶层的是一个页目录.页目录寻址最多1k 个第二级的页表. 二级的页表寻址最多1k个页. 因此,所有被页目录寻址的 表总共可以寻址1M个页,一个页4k,2^32</p>
<p>当前页目录的地址存储在CPU寄存器CR3中,页叫做页目录基址寄存器(PDBR), 内存管理软件可以选择所有task使用同一个页目录,或者每个任务都使用 独立的页目录, 或者结合的形式</p>
<h2 id="页表条目">页表条目</h2>
<p>每一级的页表的格式都相同.</p>
<h3 id="页帧地址">页帧地址</h3>
<p>页帧地址指定一个页的起始物理地址. 由于页是处于4K边界,底12位总是为0. 在页目录中,页帧地址是是页表的地址.在二级页表中,页帧地址是包含想要 的内存操作数的页帧的地址</p>
<h3 id="present-bit">present bit</h3>
<p>这个位表明页表条目是否可以用于地址转换. =1表明可用.</p>
<p>在=0的时候,条目不可用于地址转换,条目剩下的部分可以用于软件,其他的 bit也不会测试</p>
<p>如果=0,在试图使用页表条目的时候进行地址转换的时候,会产生页异常, 在支持分页虚拟内存的软件系统中,page-not-present异常handler可以 用于讲要求的页加载到物理内存中. 之后可以再次执行导致异常的指令.</p>
<p>页目录自身没有present bit. 页目录在对应的task挂起的时候也能是 not-presnet的.但是操作系统必须确保TSS的CR3映像表示的页目录 在task被调度之前是present 在内存中的.</p>
<h3 id="accessed-and-dirty-bits">accessed and dirty bits</h3>
<p>这些位提供了各种层级的页表的使用信息. 在dirty位出现在页目录条目中 的时候例外,这些位是由硬件设置的,但是处理器不会清除这些位</p>
<p>处理器在对page进行读或者写操作之前会设置对应的accessed位</p>
<p>处理器在试图写一个二级页表覆盖的地址的时候会设置其dirty bit. 目录条目中的dirty bit是未定义的</p>
<p>支持分页虚拟内存的系统可以使用这些bit来判断在内存不足的时候 哪些页从物理内存中移除</p>
<h3 id="readwrite-usersupervisor-bits">read/write user/supervisor bits</h3>
<p>这些是用于页级保护的</p>
<h2 id="页转换cache">页转换cache</h2>
<p>为了最大化页转换的效率,处理器将最近使用的页表数据保存到片内缓存中. 只在必要的分页信息不在缓存中时才会进行多级页表应用</p>
<p>页转换缓存对应用程序编程者是不可见的,系统级编程者在页表改变之后必须 刷新缓存! 页转换缓存可以通过两个方式进行:</p>
<ol>
<li>使用<code>mov</code>指令重新加载CR3寄存器</li>
<li>进程切换到与当前tss的CR3不同的tss</li>
</ol>
