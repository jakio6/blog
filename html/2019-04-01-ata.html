<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2019-04-01-ata</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="./all.css" type="text/css" media="screen" title="no title" charset="utf-8">
</head>
<body>
<header id="title-block-header">
<h1 class="title">2019-04-01-ata</h1>
</header>
<h1 id="ata-pio-mode">ATA PIO MODE</h1>
<p>根据ATA规范, 所有ATA兼容的驱动都必须支持PIO模式作为默认的数据传输机制</p>
<p>PIO模式会使用非常多的系统资源,因为在磁盘和CPU间传输的每一个字节都必须通过CPU的IO端口发送.在某些CPU中,PIO模式仍然 可以获得16MB每秒的速度,但是这是在其他进程无法获得任何CPU时间的基础上</p>
<h1 id="硬件">硬件</h1>
<p>ATA磁盘规范是基于一个旧的规范ST506的.在ST506中,每个磁盘驱动都通过两根数据线,一根数据线和一根命令线,连接到控制主板. 控制板插入到主板中.CPU通过其IO端口和直接连接到主板总线的控制板</p>
<p>最开始的IDE规范是将磁盘控制器和CPU分离的,并且每一个磁盘驱动都有一个控制器. 当CPU访问一个磁盘IO端口的时候,有一块 芯片直接讲CPU的IO总线直接短接到IDE的缆线,因此CPU可以直接访问驱动的控制器. 在CPU和控制器之间的传输机制还是一样的, 现在叫做PIO模式.(现在,磁盘控制器芯片是在IO端口总线和IDE线之间复制电平信号了,知道驱动进入PIO之外的模式)</p>
<h1 id="主从设备">主/从设备</h1>
<p>只有一根线是用于选择在每条总线上哪个驱动是激活的.不是高电平就是低电平,意味着永远不会有超过两个设备在ATA总线上同时操作. 这两个设备(??)叫做主设备和从设备,没有什么别的原因.他们的功能差不多是完全相同的.有一个特殊的IO端口允许驱动来选择使用 每个命令使用的目标驱动器(drive,driver是驱动,,,前面好像错了)</p>
<h1 id="主次总线">主/次总线</h1>
<p>目前的磁盘控制器芯片几乎都支持两根ATA总线了. 有一个套标准的IO来控制总线上的磁盘.最前面的两个叫做主和次ATA总线,并且 几乎都是由IO端口1F0到1F7,以及170到177控制的(除非你改变它).对应的设备控制寄存器/额外转台端口是3f6和376.主总线的 标准IRQ是IRQ14,IRQ15是第二跟总线</p>
<p>如果接下来还有两根总线,那通常都是有IO端口1e8到1ef和168到16f控制的.对应的设备控制寄存器/额外状态端口是IO端口3e6和366</p>
<p>实际的控制寄存器和IRQ通常可以通过枚举PCI总线来判断,找到所有的磁盘控制器,并且从每个控制器的PCI配置空间中读取信息 因此,技术上,PCI枚举应该要在ATA设备检测之前完成.然而,这个方式不是那么可靠</p>
<p>当系统引导的的时候,根据规范,PCI磁盘控制器应该要在"传统/兼容"模式.意味着它要使用标准IO端口设置.你没得选</p>
<h1 id="400ns延迟">400ns延迟</h1>
<p>在ATA规范中推荐的发送ATA命令的方式的是,在发送命令之前检查BSY和DRQ位. 这意味着你需要读一个状态寄存器(altername status是一个 不错的选择)for 适当的驱动器,在发送下一则命令之前. 意味着在可以读那个状态寄存器之前需要先选择正确的设备. 意味着驱动器的选择 要看刚好在使用状态之前进行.这很不好. 许多驱动器都需要一个最小时间来响应一个选择,并且讲他们的状态推送到总线. 建议是 在选择一个新的主或者从设备之后读5次状态寄存器,然后关注最后一次返回的值.你可以认为IO端口读差不多需要100ns的时间,因此,进行 前面的四次读可以提供400ns延迟,给驱动器提供推送正确电平到总线的时间</p>
<p>通过读取IO端口产生延迟会浪费大量的CPU时间.因此,让驱动记住最后发送到xx的值来避免进行不必要的驱动器选择是最好的.如果你没有发送 驱动器选择,那么你只需要读一次状态寄存器</p>
<p>另外,不要向已经在服务上一个命令的驱动器发送新的命令.如果当前设备在修改BSY/DRQ/ERR的时候你的驱动总是需要阻塞,并且的设备驱动 总是已经知道设备是处于那个状态(因为磁盘驱动刚刚向设备发送了命令,并且还没有标记为完成(反正我现在什么都不懂)).一旦驱动器完成了 一条命令,他会清除BSY(busy?)和DRQ.你可以在下一条设备选择命令之前验证这个,先前选择的涉笔会在命令结束的时候正确地清除BSY和DRQ. 如果在设备选择之后他们清除你,你不需要进行检查,所以在设备选择之后不需要读取状态寄存器</p>
<p>(觉得我这样有点蠢啊妈的)</p>
<p>在命令寄存器的ERR/DF位之后有类似的文艺.他们是两种可以结束一个命令错误类型. BSY和DRQ会被清楚吧,但是ERR和DF会保持到你向 命令寄存器写新的命令之前.如果你使用轮询的话,你应该要算上你开始的四次读状态寄存器,在发送命令字节之后,可能会RANGEERR和DF意外设置.. (如果你使用IRQs,状态会在IRQ被服务的时候纠正)</p>
<h1 id="缓存刷新">缓存刷新</h1>
<p>在某些驱动器上在每次写命令之后需要手动刷新缓存. 这个是通过发送0xe7命令到命令寄存器来实现的(然后等待BSY清除).如果一个驱动没有 这样做,那么接下来的写命令可能会失败,invisibly,或者可能会在你的disk上临时的损坏扇区</p>
<h1 id="损坏扇区">损坏扇区</h1>
<p>就实际而言,在ATA磁盘上有三种不同类型的孙欢扇区</p>
<ul>
<li>不能写(永久)</li>
<li>不能读(永久)</li>
<li>不能读(临时)</li>
</ul>
<p>某些磁盘制造厂商有提供少量用于重新映射到永久损坏扇区的扇区的机制. 但是,这不是标准的,完全是看厂商的. 通常来说,OS/文件系统需要 为每个驱动器的每个分区保持一个损坏扇区列表,并且处理损坏扇区</p>
<p>就像上面说的那样,还存在临时的损坏.当读的时候会得到硬件错误信息,就像永久损坏的扇区一样.但是如果你写那个扇区的话,却是可以正常工作的. 临时损坏可能会在有没有刷新的写缓存,电源峰值,或者供电故障的时候发送</p>
<h1 id="检测和初始化">检测和初始化</h1>
<h2 id="浮动总线">浮动总线</h2>
<p>最后一次选择的磁盘(bios在引导期间选择)需要维护每根IDE总线上的电平值.如果没有磁盘连接到总心啊,那么就都是高点评.计算机会将其看成 0xff字节(!),这是一种叫做浮动总线的情况. 通过这种方式来判断总线上有没有驱动器是非常不错的.在发送任何数据到IO端口之前,先读取普通 状态寄存器. 值0xff是不合法的状态值,其表示总线上没有驱动器. 要在写之前读取端口的原因是,写的操作会导致线上的电平改变一段时间 (因为可能没有人在控制线上的电平),可能会与对浮动的测试混淆.</p>
<p>测量浮动是检查驱动器是否存在的快捷房还是.读取一个非0xff的值是不明确的.检测驱动器的是绝对准确的方式是xx 命令</p>
<h1 id="检测控制器io端口">检测控制器IO端口</h1>
<p>检测控制其IO端口可能就是在浪费时间. 在引导期间, 分配给ATA总线的IO端口应该是会在标准的地址的.如果不在, 就只能通过枚举 PCI总线上的磁盘控制器来找到他们了. 而,如果端口位于标准端口,检测他们就毫无意义. 但是你可以看到的检测代码工作,并且能够 识别它,之外是干什么娶你德玛. 如果你知道IO控制器端口位置,比起那个企鹅至少有一个驱动器附加到那根总线,那么你可以检测 这些IO端口. ATA控制器IO端口对数都是读写端口.意味着如果你将一个值写到扇区统计端口,就可以从相同的端口再讲这个值读回来,来看 它到底设置成了什么样. 这个读写函数是通过总线上的主驱动器进行的,除非从驱动器也存在并且选择了.需要注意的是,如果你将值写到一个 不存在的IO端口,如果读取够快的话,也是可以从总线上将那个值读回来的.因此,一般来说,ATA IO端口检测软件是否工作的方式将一个 字节写到一个suspected ATA IO端口,然后读回并检测写到两个端口的值.如果两个字节都验证通过了,那么就是读写端口,之后就可以 认为他们是ATA控制器IO端口.在主总线上,0x1f2dao0x1f5应该都是读写端口</p>
<h2 id="标准和非标准检测">标准和非标准检测</h2>
<p>所有当前的BIOS都已经使用IDENTIFY作为检测所有ATA总线设备的命令</p>
<p>还有两个不推荐的非标准方式. 第一个是选择一个设备然后读取设备的状态寄存器. 没有sleeping的设备,RDY位总是设备的. ...</p>
<p>另一个方式是使用执行设备诊断命令(0x90). 他会设置错误寄存器中的bit(主总线上的0x1f1)来显示总线上主设备和从设备是否存在</p>
<h1 id="identify命令">IDENTIFY命令</h1>
<p>要使用IDENTIFY命令,给驱动器选择端口发送0xa0或0xb0来分别选择主驱动器和从驱动器. 在主总线上,这个驱动器选择端口应该是 端口0x1f6. 然后设置扇区统计,LBAI0,LBAmid,和LBAhi IO端口为0.然后发送IDENTIFY命令到明明IO端口.然后再次读取状态寄存器. 如果值是0,驱动器就不存在,其他值的话,轮询状态端口,知道BSY为clear.因为某些ATAPI驱动器并不遵从规范,这个时候需要检查.... 来看是否是非0.如果是,驱动器就不是ATA.你就应该停止轮询.否则,继续轮询状态端口知道DRQ set或者ERR set</p>
<p>在那个点的时候,如果ERR是clear的,数据将从数据端口读出(0x1f0).读256个16bit的值,并且存储</p>
<h1 id="命令退出">命令退出</h1>
<p>ATAPI和SATA设备会通过立即在状态寄存器中汇报错误来响应一个ATA IDENTIFY命令,而不是先设置BSY再设置DRQ,然后再发送256个16bit PIO数据值.这些设备也会将特定的值写到IO端口,也可以被读. 在IDENTIFY之后,如果看到了ATAPI专门的值,就可以确定设备是ATAPI了, 在主从先上,IO端口0x1f4会浮沉0x14,在IO端口0x1f5会被看成0XEB.(??). 如果一个正常的ATA驱动器总是不会中断IDENTIFY命令,在这 两个端口中的值会为0. 一个SATA设备会汇报0x3c,和0xc3. 看下面的代码实例</p>
<p><strong>但是</strong>, 也有一些ATAPI驱动器在终端一个ATA IDENTIFY命令之后不会设置ERR标识.因此, 不要完全依赖IDENTIFY之后的ERR标识</p>
<h1 id="寻址模式">寻址模式</h1>
<p>当前有三种寻址模式来选择读写一个磁盘上的特定的扇区.有28bit LBA,48bit LBA以及CHS.CHS模式已经废除了,但是会快速介绍. LBA模式中引用扇区地址中有效位的的bit的数量叫做LBA. 在28bit模式中,从0到0xfffffff是合法的.这可以寻址256m扇区,或者128GB的 寻址控制.因此28bit模式在当前许多驱动器中有已经废除了.然而,28bit PIO模式比48bit寻址模式更快,因此在没有超过最大LBA值限制 的分区使用28bit PIO模式是更好的</p>
<h1 id="绝对相对-lba">绝对/相对 LBA</h1>
<p>所有使用LBA寻址的ATA命令都需要绝对LBA(就是从磁盘开始的扇区偏移,忽略分区).乍一看,在OS中以相同的形式存储LBA值似乎是最有效的. 然而,实际情况并不是这样.总是有必要验证传给你的驱动器的LBA的合法性,因为它实际是属于(相对与)正在访问的分区的.最终还是使用 使用分区相对的LBA寻址最好了,因为这样你就不需要检查被访问的LBA是不是相对当前分区的偏移.许多测试就只需要进行一半了.这弥补了 需要将xxx添加到当前分区开始的消耗..同时,也可以多一个LBA寻址位的访问能力(??)</p>
<h1 id="寄存器">寄存器</h1>
<p>ATA总线通常有10个控制其行为的端口.主总线上..某些系统有非标准的ATA总线端口位置,这个时候需要访问PCI部分来判断如何提取系统中 不同的设备端口地址了</p>
<p>这些表中....</p>
</body>
</html>
